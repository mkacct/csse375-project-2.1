@startuml

package presentation {

	+class Main {
		- {static} <<final>> CHECKS: Check[]
		+ {static} main(args: String[]): void
		- {static} printUsage(): void
	}

	Main -->"*" .domain.Check
	Main ..> App
	Main ..> .datasource.DirLoader
	Main ..> .datasource.JsonFileConfigLoader

	~class App {
		- {static} <<final>> ENABLE_KEY_PREFIX: String
		- {static} <<final>> SKIP_UNMARKED_CHECKS_KEY: String
		- {static} <<final>> MESSAGE_LEVEL_COLORS: Map<MessageLevel, TerminalTextColor>
		- filesLoader: FilesLoader
		- configLoader: ConfigLoader

		~ App(filesLoader: FilesLoader, configLoader: ConfigLoader)
		~ run(checks: Check[]): boolean
		- {static} readInClasses(classFiles: Set<byte[]>): Map<String, ClassData>
		- {static} runAllChecksAndPrintResults(checks: Check[], classes: Map<String, ClassData>, config: Configuration): Map<MessageLevel, Integer>
		- {static} readConfigBoolAndFallbackIfWrongType(config: Configuration, key: String, fallback: boolean): boolean
		- {static} runCheckAndPrintResults(check: Check, classes: Map<String, ClassData>, config: Configuration, msgTotals: Map<MessageLevel, Integer>): void
		- {static} colorMessageTag(msg: Message): String
		- {static} printTotals(msgTotals: Map<MessageLevel, Integer>): void
		- {static} generateTotalsTerm(totalsTerms: List<String>, level: MessageLevel, count: int): void
		- {static} initMsgTotals(): Map<MessageLevel, Integer>
	}

	App --> .datasource.FilesLoader
	App --> .datasource.ConfigLoader
	App ..> TerminalTextColor
	App ..> .domain.Check
	App ..> .domain.Message
	App ..> .domain.MessageLevel
	App ..> .domain.javadata.ClassData
	App ..> .domain.javadata.ClassNodeAdapter
	App ..> .datasource.Configuration

	~enum TerminalTextColor {
		BLACK
		RED
		GREEN
		YELLOW
		BLUE
		PURPLE
		CYAN
		WHITE
		__
		- {static} <<final>> RESET: String
		- <<final>> ansiCode: String
		__
		- TerminalTextColor(ansiCode: String)
		+ applyTo(text: String): String
	}

}

package domain {

	+enum MessageLevel {
		ERROR
		WARNING
		INFO
		__
		+ <<final>> abbreviation: String
		__
		- MessageLevel(abbrev: String)
	}

	+interface Check {
		+ {abstract} getName(): String
		+ {abstract} run(classes: Map<String, ClassData>, config: Configuration): Set<Message>
	}

	Check ..> Message
	Check ..> javadata.ClassData
	Check ..> .datasource.Configuration

	+class Message <<final>> {
		+ <<final>> level: MessageLevel
		+ <<final>> text: String
		- <<final>> classFullNames: Set<String>

		+ Message(level: MessageLevel, text: String, classFullNames: Set<String>)
		+ Message(level: MessageLevel, text: String, classFullName: String)
		+ Message(level: MessageLevel, text: String)
		+ getClassFullNames(): Set<String>
		+ toString(): String
		+ equals(obj: Object): boolean
		+ hashCode(): int
	}

	Message --> MessageLevel

	+class MethodLengthCheck {
		- {static} <<final>> NAME: String
		- {static} <<final>> MAX_METHOD_LENGTH_KEY: String
		+ getName(): String
		+ run(classes: Map<String, ClassData>, config: Configuration): Set<Message>
		- checkClass(classData: ClassData, maxMethodLengthInstrs: int, messages: Set<Message>): void
	}

	Check <|.. MethodLengthCheck
	MethodLengthCheck ..> MessageLevel
	MethodLengthCheck ..> javadata.MethodData
	MethodLengthCheck ..> javadata.InstrData

	package javadata {

		+enum AccessModifier {
			PUBLIC
			PROTECTED
			PACKAGE_PRIVATE
			PRIVATE

			~ {static} parseOpcodes(access: int): AccessModifier
		}

		AccessModifier ..> .asm.Opcodes

		+enum ClassType {
			CLASS
			INTERFACE
			ENUM

			~ {static} parseOpcodes(access: int): ClassType
		}

		ClassType ..> .asm.Opcodes

		+class VariableData <<final>> {
			+ <<final>> name: String
			+ <<final>> typeFullName: String

			+ VariableData(name: String, typeFullName: String)
			+ equals(obj: Object): boolean
			+ hashCode(): int
		}

		+interface ClassData {
			+ {abstract} getFullName(): String
			+ {abstract} getAccessModifier(): AccessModifier
			+ {abstract} getClassType(): ClassType
			+ {abstract} isAbstract(): boolean
			+ {abstract} isStatic(): boolean
			+ {abstract} isFinal(): boolean
			' + {abstract} getTypeParamFullNames(): List<String>
			+ {abstract} getSuperFullName(): String
			+ {abstract} getInterfaceFullNames(): Set<String>
			+ {abstract} getFields(): Set<FieldData>
			+ {abstract} getMethods(): Set<MethodData>
			+ {abstract} getContainingClassFullName(): String
			+ {abstract} getInnerClassFullNames(): Set<String>
		}

		ClassData ..> AccessModifier
		ClassData ..> ClassType
		ClassData ..> FieldData
		ClassData ..> MethodData

		+interface FieldData {
			+ {abstract} getName(): String
			+ {abstract} getTypeFullName(): String
			+ {abstract} getAccessModifier(): AccessModifier
			+ {abstract} isStatic(): boolean
			+ {abstract} isFinal(): boolean
		}

		FieldData ..> AccessModifier

		+interface MethodData {
			+ {static} <<final>> CONSTRUCTOR_NAME: String
			+ {static} <<final>> STATIC_INITIALIZER_NAME: String

			+ {abstract} getName(): String
			+ {abstract} getReturnTypeFullName(): String
			+ {abstract} getAccessModifier(): AccessModifier
			+ {abstract} isStatic(): boolean
			+ {abstract} isFinal(): boolean
			+ {abstract} isAbstract(): boolean
			+ {abstract} getParams(): List<VariableData>
			+ {abstract} getExceptionTypeFullNames(): Set<String>
			+ {abstract} getLocalVariables(): Set<VariableData>
			+ {abstract} getInstructions(): List<InstrData>
		}

		MethodData ..> AccessModifier
		MethodData ..> VariableData
		MethodData ..> InstrData

		+class ClassReaderUtil {
			+ {static} read(javaBytecode: byte[]): ClassData
		}

		ClassReaderUtil ..> ClassNodeAdapter
		ClassReaderUtil ..> .asm.ClassReader
		ClassReaderUtil ..> .asm.tree.ClassNode

		~class ClassNodeAdapter {
			- <<final>> classNode: ClassNode

			~ ClassNodeAdapter(classNode: ClassNode)
			+ getFullName(): String
			+ getAccessModifier(): AccessModifier
			+ getClassType(): ClassType
			+ isAbstract(): boolean
			+ isStatic(): boolean
			+ isFinal(): boolean
			' + getTypeParamFullNames(): List<String>
			+ getSuperFullName(): String
			+ getInterfaceFullNames(): Set<String>
			+ getFields(): Set<FieldData>
			+ getMethods(): Set<MethodData>
			+ getContainingClassFullName(): String
			+ getInnerClassFullNames(): Set<String>
		}

		ClassData <|.. ClassNodeAdapter
		ClassNodeAdapter --> .asm.tree.ClassNode
		ClassNodeAdapter ..> FieldNodeAdapter
		ClassNodeAdapter ..> MethodNodeAdapter
		ClassNodeAdapter ..> .asm.Opcodes
		ClassNodeAdapter ..> .asm.Type
		ClassNodeAdapter ..> .asm.tree.FieldNode
		ClassNodeAdapter ..> .asm.tree.MethodNode

		~class FieldNodeAdapter {
			- <<final>> fieldNode: FieldNode

			~ FieldNodeAdapter(fieldNode: FieldNode)
			+ getName(): String
			+ getTypeFullName(): String
			+ getAccessModifier(): AccessModifier
			+ isStatic(): boolean
			+ isFinal(): boolean
		}

		FieldData <|.. FieldNodeAdapter
		FieldNodeAdapter --> .asm.tree.FieldNode
		FieldNodeAdapter ..> .asm.Opcodes
		FieldNodeAdapter ..> .asm.Type

		~class LocalVariableUtil {
			~ {static} findLocalVariableNode(var: int, localVars: List<LocalVariableNode>): LocalVariableNode
		}

		LocalVariableUtil ..> .asm.tree.LocalVariableNode

		~class MethodNodeAdapter {
			- {static} <<final>> THIS: String
			- <<final>> methodNode: MethodNode

			~ MethodNodeAdapter(methodNode: MethodNode)
			+ getName(): String
			+ getReturnTypeFullName(): String
			+ getAccessModifier(): AccessModifier
			+ isStatic(): boolean
			+ isFinal(): boolean
			+ isAbstract(): boolean
			+ getParams(): List<VariableData>
			+ getExceptionTypeFullNames(): Set<String>
			+ getLocalVariables(): Set<VariableData>
			+ getInstructions(): List<InstrData>
			- createInsnNodeAdapter(insn: AbstractInsnNode): InstrData
		}

		MethodData <|.. MethodNodeAdapter
		MethodNodeAdapter ..> MethodInsnNodeAdapter
		MethodNodeAdapter ..> VarInsnNodeAdapter
		MethodNodeAdapter ..> FieldInsnNodeAdapter
		MethodNodeAdapter ..> OtherInsnNodeAdapter
		MethodNodeAdapter ..> LocalVariableUtil
		MethodNodeAdapter --> .asm.tree.MethodNode
		MethodNodeAdapter ..> .asm.Opcodes
		MethodNodeAdapter ..> .asm.Type
		MethodNodeAdapter ..> .asm.tree.LocalVariableNode
		MethodNodeAdapter ..> .asm.tree.AbstractInsnNode
		MethodNodeAdapter ..> .asm.tree.MethodInsnNode
		MethodNodeAdapter ..> .asm.tree.VarInsnNode
		MethodNodeAdapter ..> .asm.tree.FieldInsnNode

		+enum InstrType {
			METHOD
			LOCAL_VARIABLE
			FIELD
		}

		+interface InstrData {
			+ {abstract} getInstrType(): InstrType
		}

		InstrData ..> InstrType

		+enum VariableOperation {
			GET
			SET
			RETURN

			~ {static} parseOpcode(opcode: int): VariableOperation
		}

		VariableOperation ..> .asm.Opcodes

		+interface MethodInstrData {
			+ {abstract} getMethodOwnerFullName(): String
			+ {abstract} getMethodName(): String
			+ {abstract} getMethodReturnTypeFullName(): String
		}

		InstrData <|.. MethodInstrData

		+interface LocalVariableInstrData {
			+ {abstract} getVarName(): String
			+ {abstract} getVarTypeFullName(): String
			+ {abstract} getOperation(): VariableOperation
		}

		InstrData <|.. LocalVariableInstrData
		LocalVariableInstrData ..> VariableOperation

		+interface FieldInstrData {
			+ {abstract} getFieldOwnerFullName(): String
			+ {abstract} getFieldName(): String
			+ {abstract} getFieldTypeFullName(): String
			+ {abstract} getOperation(): VariableOperation
		}

		InstrData <|.. FieldInstrData
		FieldInstrData ..> VariableOperation

		~class MethodInsnNodeAdapter {
			- <<final>> insn: MethodInsnNode
			~ MethodInsnNodeAdapter(insn: MethodInsnNode)
			+ getInstrType(): InstrType
			+ getMethodOwnerFullName(): String
			+ getMethodName(): String
			+ getMethodReturnTypeFullName(): String
		}

		MethodInstrData <|.. MethodInsnNodeAdapter
		MethodInsnNodeAdapter --> .asm.tree.MethodInsnNode
		MethodInsnNodeAdapter ..> .asm.Type

		~class VarInsnNodeAdapter {
			- <<final>> insn: VarInsnNode
			- <<final>> localVariableNode: LocalVariableNode
			~ VarInsnNodeAdapter(insn: VarInsnNode, localVars: List<LocalVariableNode>)
			+ getInstrType(): InstrType
			+ getVarName(): String
			+ getVarTypeFullName(): String
			+ getOperation(): VariableOperation
		}

		LocalVariableInstrData <|.. VarInsnNodeAdapter
		VarInsnNodeAdapter ..> LocalVariableUtil
		VarInsnNodeAdapter --> .asm.tree.VarInsnNode
		VarInsnNodeAdapter --> .asm.tree.LocalVariableNode
		VarInsnNodeAdapter ..> .asm.Type

		~class FieldInsnNodeAdapter {
			- <<final>> insn: FieldInsnNode
			~ FieldInsnNodeAdapter(insn: FieldInsnNode)
			+ getInstrType(): InstrType
			+ getOwnerFullName(): String
			+ getFieldName(): String
			+ getFieldTypeFullName(): String
			+ getOperation(): VariableOperation
		}

		FieldInstrData <|.. FieldInsnNodeAdapter
		FieldInsnNodeAdapter --> .asm.tree.FieldInsnNode
		FieldInsnNodeAdapter ..> .asm.Type

		~class OtherInsnNodeAdapter {
			+ getInstrType(): InstrType
		}

		InstrData <|.. OtherInsnNodeAdapter

	}

}

package datasource {

	+interface FilesLoader {
		+ {abstract} loadFiles(ext: String): Set<byte[]>\n<<throws>> IOException
	}

	+class DirLoader {
		- <<final>> path: String

		+ DirLoader(path: String)
		+ loadFiles(ext: String): Set<byte[]> <<throws>> IOException
		- addFilesFromDir(files: Set<byte[]>, dir: File, ext: String): void\n<<throws>> IOException
		- readFile(file: File): byte[] <<throws>> IOException
	}

	FilesLoader <|.. DirLoader

	+class Configuration <<final>> {
		- <<final>> data: Map<String, Object>

		+ Configuration(data: Map<String, Object>)
		+ getBoolean(key: String): boolean\n<<throws>> IllegalArgumentException,\nClassCastException
		+ getInt(key: String): int\n<<throws>> IllegalArgumentException,\nClassCastException
		+ getString(key: String): String\n<<throws>> IllegalArgumentException,\nClassCastException
		+ getBoolean(key: String, fallback: boolean): boolean
		+ getInt(key: String, fallback: int): int
		+ getString(key: String, fallback: String): String
	}

	+interface ConfigLoader {
		+ {abstract} loadConfig(): Configuration\n<<throws>> IOException
	}

	ConfigLoader ..> Configuration

	+class JsonFileConfigLoader {
		- <<final>> path: String

		+ JsonFileConfigLoader(path: String)
		+ loadConfig(): Configuration\n<<throws>> IOException
	}

	ConfigLoader <|.. JsonFileConfigLoader
	JsonFileConfigLoader ..> .json.JSONObject

}

package asm {

	+interface Opcodes {
		...
	}

	+class Type <<final>> {
		...
	}

	+class ClassReader {
		...
	}

	hide methods

	package tree {

		+class ClassNode {
			...
		}

		+class FieldNode {
			...
		}

		+class MethodNode {
			...
		}

		+class LocalVariableNode {
			...
		}

		+abstract AbstractInsnNode {
			...
		}

		+class MethodInsnNode {
			...
		}

		+class VarInsnNode {
			...
		}

		+class FieldInsnNode {
			...
		}

		AbstractInsnNode <|-- MethodInsnNode
		AbstractInsnNode <|-- VarInsnNode
		AbstractInsnNode <|-- FieldInsnNode

		hide methods

	}

}

package json {

	+class JSONObject {
		...
	}

	hide methods
}

@enduml
