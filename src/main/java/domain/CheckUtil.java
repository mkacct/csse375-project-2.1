package domain;

import java.text.MessageFormat;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;

import datasource.Configuration;
import domain.javadata.ClassData;
import domain.javadata.ClassDataCollection;
import domain.javadata.ClassReaderUtil;

/**
 * Methods used for running checks, called by presentation layers (CLI or GUI).
 */
public final class CheckUtil {
	/**
	 * File name extension for Java class files.
	 */
	public static final String CLASS_FILE_EXT = "class";

	public static final String ENABLE_KEY_PREFIX = "enable_";

	private static final String SKIP_UNMARKED_CHECKS_KEY = "skipUnmarkedChecks";

	/**
	 * Parses Java bytecode into ClassData objects.
	 * @param classFiles set of Java class files' byte arrays
	 * @return ClassDataCollection of the generated ClassData objects
	 */
	public static ClassDataCollection readInClasses(Set<byte[]> classFiles) {
		ClassDataCollection classes = new ClassDataCollection();
		for (byte[] classFile : classFiles) {
			ClassData classData = ClassReaderUtil.read(classFile);
			classes.add(classData);
		}
		return classes;
	}

	/**
	 * Runs checks on the given classes in accordance with the given configuration.
	 * @param checks all checks (runAllChecks will filter using config)
	 * @param classes ClassDataCollection to run checks on
	 * @param config user's configuration
	 * @param msgTotals initially empty mutable map that will be populated with message totals
	 * @param resultsHandler function that takes a check name and the set of messages generated by that check (for output)
	 * @return number of checks run
	 */
	public static int runAllChecks(
		Check[] checks,
		ClassDataCollection classes,
		Configuration config,
		Map<MessageLevel, Integer> msgTotals,
		BiConsumer<String, Set<Message>> resultsHandler
	) {
		initMsgTotals(msgTotals);
		boolean skipUnmarked = config.getBoolean(SKIP_UNMARKED_CHECKS_KEY, false);
		int numChecksRun = 0;
		for (Check check : checks) {
			Boolean configVal = config.getBoolean(ENABLE_KEY_PREFIX + check.name, null);
			if (skipUnmarked ? Boolean.TRUE.equals(configVal) : check.isEnabled(configVal)) {
				runCheck(check, classes, config, msgTotals, resultsHandler);
				numChecksRun++;
			}
		}
		return numChecksRun;
	}

	private static void runCheck(
		Check check,
		ClassDataCollection classes,
		Configuration config,
		Map<MessageLevel, Integer> msgTotals,
		BiConsumer<String, Set<Message>> resultsHandler
	) {
		Set<Message> generatedMsgs;
		try {
			generatedMsgs = check.run(classes, config);
		} catch (Exception ex) {
			generatedMsgs = Set.of(
				new Message(MessageLevel.ERROR, MessageFormat.format("Check threw exception: {0}", ex.getMessage()))
			);
		}
		for (Message msg : generatedMsgs) {
			msgTotals.put(msg.level, msgTotals.get(msg.level) + 1);
		}
		resultsHandler.accept(check.name, generatedMsgs);
	}

	private static void initMsgTotals(Map<MessageLevel, Integer> msgTotals) {
		for (MessageLevel level : MessageLevel.values()) {
			msgTotals.put(level, 0);
		}
	}
}
