@startuml
left to right direction
' scale 1024 width
' scale 768 height

package "cli" {
  class App {
    -{static} MESSAGE_LEVEL_COLORS: Map<MessageLevel, TerminalTextColor>
    -filesLoader: FilesLoader
    -configLoader: ConfigRW
    -outStream: PrintStream
    -errStream: PrintStream
    ~run(check: Check[]): boolean
    -printCheckResults(checkName: String, generatedMsgs: Set<Message>): void
    -{static} colorMessageTag(msg: Message): String
    -printTotals(msgTotals: Map<MessageLevel, Integer>): void
    -{static} generateTotalsTerm(totalsTerms: List<String>, level: MessageLevel, count: int): void
  }

  enum TerminalTextColor {
    BLACK
    RED
    GREEN
    YELLOW
    BLUE
    PURPLE
    CYAN
    WHITE
    -{static} RESET: String
   -ansiCode: String
    +applyTo(text: String): String
  }
}

package datasource.configspec {
  class ConfigSpec {
    -sections: List<Section>
  }
  class Section {
    -{static} DEFAULT_ENTITY_TYPE: String
    -title: String
    -checkName: String
    -entityType: String
    -settings: List<Setting>
    +representsCheck(): boolean
    -validateRepresentsCheck(): void

  }
  class Setting {
    -name: String
    -type: Type
    -desc: String
    -options: List<String>
    +hasStringOptions(): boolean
    -validateCanHaveOptions(): void
  }
  enum Type {
    BOOLEAN
    INT
    STRING
    LIST_OF_BOOLEAN
    LIST_OF_INT
    LIST_OF_STRING
    {static} parse(typeName: String): Type
  }

  interface ConfigSpecLoader {
    loadConfigSpec(): ConfigSpec
  }

  class JsonFileConfigSpecLoader {
    +{static} CONFIG_SPEC_PATH: String
    -configSpecPath: String
    +loadConfigSpec(): ConfigSpec
    -readSelects(selectsJson: JSONObject): Map<String, List<String>>
    -readSections(sectionsJson: JSONArray, selects: Map<String, List<String>>): List<ConfigSpec.Section>
    -readSettings(sectionJson: JSONObject, selects: Map<String, List<String>>): List<ConfigSpec.Setting>
    -readSetting(settingJson: JSONObject, selects: Map<String, List<String>>): ConfigSpec.Setting
    -{static} getStringOrNull(jsonObject: JSONObject, key: String): String
  }
}

package datasource {
  interface ConfigRW {
    sourceExists(): boolean
    loadConfig(): Configuration
    saveConfig(config: Configuration): void
  }

  class Configuration {
    -data: Map<String, Object>
    -checkKey(key: String): void
    +applyChanges(changes: Map<String, Object>): Configuration
  }

  interface DataPrinter {
    print(s: String): void
  }

  class DirLoader {
    -path: String
    +loadFiles(ext: String): Set<byte[]>
    -addFilesFromDir(files: Set<byte[]>, dir: File, ext: String)
    -readFile(file: File): byte[]
  }

  interface FilesLoader {
    loadFiles(ext: String): Set<byte[]>
  }

  class FullFilePrinter {
    -path: String
    +print(s: String): void
  }

  class JsonFileConfigRW {
    -{static} JSON_INDENT: int
    -path: String
    +sourceExists(): boolean
    +loadConfig(): Configuration
    +saveConfig(config: Configuration): void
  }
}

package domain.checks {
  class AdapterPatternCheck {
    -{static} NAME: String
    -{static} ADAPTER_CLASS_NAME_REGEX_KEY: String
    -{static} DEFAULT_ADAPTER_CLASS_NAME_REGEX: String
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
    -{static} findAdapters(classes: ClassDataCollection, adapterNamePattern: Pattern, messages: Set<Message>): Set<String>
    -{static} validateUsageOfAdapters(classes: ClassDataCollection, adapterFullNames: Set<String>, messages: Set<Messages>): void
  }

  class ConstantInterfaceCheck {
    -{static} NAME: String
    -{static} ALLOW_MARKER_INTERFACES_KEY: String
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
  }

  class CountCheckPropertyValidator {
    -generatedMessage: Message
    +validateGetInt(config: Configuration, key: String): Integer
  }

  abstract class GraphCheck {
    #graph: ClassGraph
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
    +{abstract} gRun(config: Configuration): Set<Message>
  }

  class ImmutableExceptionsCheck {
    -{static} NAME: String
    -{static} EXCEPTION_CLASS_NAME_REGEX: String
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
    -{static} checkExceptionsClass(classData: ClassData, messages: Set<Message>): void
  }
}

exception IOException {
}

exception Exception {
}

exception IllegalArgumentException {
}

exception RuntimeException {
}

exception FileNotFoundException {
}

exception IllegalStateException {
}

exception ClassCastException {
}
' cli package
App -> ConfigRW
App -> FilesLoader

' datasource.config package
ConfigSpec +- Section
ConfigSpec ->"*" Section
Section +- Setting
Section ->"*" Setting
Setting +- Type
Setting -> Type
JsonFileConfigSpecLoader .|> ConfigSpecLoader

' datasource package
DirLoader ..|> FilesLoader
FullFilePrinter ..|> DataPrinter
JsonFileConfigRW ..|> ConfigRW
ConfigSpecLoader ..> IOException: <<throws>>
JsonFileConfigSpecLoader ..> IOException: <<throws>>
ConfigRW ..> IOException: <<throws>>
Configuration ..> IllegalArgumentException: <<throws>>
Configuration ..> ClassCastException: <<throws>>
DataPrinter ..> FileNotFoundException: <<throws>>
FilesLoader ..> IOException: <<throws>>
FilesLoader ..> IllegalStateException: <<throws>>

' domain.checks package
AdapterPatternCheck --|> Check
ConstantInterfaceCheck --|> Check
GraphCheck  --|> Check
ImmutableExceptionsCheck --|> Check

' exceptions
FileNotFoundException --|> IOException
IOException --|> Exception
ClassCastException --|> RuntimeException
IllegalStateException --|> RuntimeException
IllegalArgumentException --|> RuntimeException
RuntimeException --|> Exception
@enduml