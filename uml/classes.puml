@startuml
left to right direction
' scale 1024 width
' scale 768 height

package "cli" {
  class App {
    -{static} MESSAGE_LEVEL_COLORS: Map<MessageLevel, TerminalTextColor>
    -filesLoader: FilesLoader
    -configLoader: ConfigRW
    -outStream: PrintStream
    -errStream: PrintStream
    ~run(check: Check[]): boolean
    -printCheckResults(checkName: String, generatedMsgs: Set<Message>): void
    -{static} colorMessageTag(msg: Message): String
    -printTotals(msgTotals: Map<MessageLevel, Integer>): void
    -{static} generateTotalsTerm(totalsTerms: List<String>, level: MessageLevel, count: int): void
  }

  enum TerminalTextColor {
    BLACK
    RED
    GREEN
    YELLOW
    BLUE
    PURPLE
    CYAN
    WHITE
    -{static} RESET: String
   -ansiCode: String
    +applyTo(text: String): String
  }
}

package datasource.configspec {
  class ConfigSpec {
    -sections: List<Section>
  }
  class Section {
    -{static} DEFAULT_ENTITY_TYPE: String
    -title: String
    -checkName: String
    -entityType: String
    -settings: List<Setting>
    +representsCheck(): boolean
    -validateRepresentsCheck(): void

  }
  class Setting {
    -name: String
    -type: Type
    -desc: String
    -options: List<String>
    +hasStringOptions(): boolean
    -validateCanHaveOptions(): void
  }
  enum Type {
    BOOLEAN
    INT
    STRING
    LIST_OF_BOOLEAN
    LIST_OF_INT
    LIST_OF_STRING
    {static} parse(typeName: String): Type
  }

  interface ConfigSpecLoader {
    loadConfigSpec(): ConfigSpec
  }

  class JsonFileConfigSpecLoader {
    +{static} CONFIG_SPEC_PATH: String
    -configSpecPath: String
    +loadConfigSpec(): ConfigSpec
    -readSelects(selectsJson: JSONObject): Map<String, List<String>>
    -readSections(sectionsJson: JSONArray, selects: Map<String, List<String>>): List<ConfigSpec.Section>
    -readSettings(sectionJson: JSONObject, selects: Map<String, List<String>>): List<ConfigSpec.Setting>
    -readSetting(settingJson: JSONObject, selects: Map<String, List<String>>): ConfigSpec.Setting
    -{static} getStringOrNull(jsonObject: JSONObject, key: String): String
  }
}

package datasource {
  interface ConfigRW {
    sourceExists(): boolean
    loadConfig(): Configuration
    saveConfig(config: Configuration): void
  }

  class Configuration {
    -data: Map<String, Object>
    -checkKey(key: String): void
    +applyChanges(changes: Map<String, Object>): Configuration
  }

  interface DataPrinter {
    print(s: String): void
  }

  class DirLoader {
    -path: String
    +loadFiles(ext: String): Set<byte[]>
    -addFilesFromDir(files: Set<byte[]>, dir: File, ext: String)
    -readFile(file: File): byte[]
  }

  interface FilesLoader {
    loadFiles(ext: String): Set<byte[]>
  }

  class FullFilePrinter {
    -path: String
    +print(s: String): void
  }

  class JsonFileConfigRW {
    -{static} JSON_INDENT: int
    -path: String
    +sourceExists(): boolean
    +loadConfig(): Configuration
    +saveConfig(config: Configuration): void
  }
}

package domain.checks {
  class AdapterPatternCheck {
    -{static} NAME: String
    -{static} ADAPTER_CLASS_NAME_REGEX_KEY: String
    -{static} DEFAULT_ADAPTER_CLASS_NAME_REGEX: String
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
    -{static} findAdapters(classes: ClassDataCollection, adapterNamePattern: Pattern, messages: Set<Message>): Set<String>
    -{static} validateUsageOfAdapters(classes: ClassDataCollection, adapterFullNames: Set<String>, messages: Set<Messages>): void
  }

  class ConstantInterfaceCheck {
    -{static} NAME: String
    -{static} ALLOW_MARKER_INTERFACES_KEY: String
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
  }

  class CountCheckPropertyValidator {
    -generatedMessage: Message
    +validateGetInt(config: Configuration, key: String): Integer
  }

  abstract class GraphCheck {
    #graph: ClassGraph
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
    +{abstract} gRun(config: Configuration): Set<Message>
  }

  class ImmutableExceptionsCheck {
    -{static} NAME: String
    -{static} EXCEPTION_CLASS_NAME_REGEX: String
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
    -{static} checkExceptionsClass(classData: ClassData, messages: Set<Message>): void
  }

  class InformationHidingCheck {
    -{static} NAME: String
    -{static} GETTER_SETTER_LENGTH: int
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
    -indicateFieldsWithInformationHiding(publicFieldsToClass: Map<String, ArrayList<String>): Set<Message>
    -informationHidingClassCheck(classes: ClassDataCollection, publicFieldsToClass: Map<String, ArrayList<String>): void
    -checkFieldModifiers(fields: Set<FieldData>, publicFieldsToClass: Map<String, ArrayList<String>, currentClass: ClassData): void
    -checkForGettersAndSetters(field: FieldData, publicFieldsToClass: Map<String, ArrayList<String>, currentClass: ClassData): void
    -matchingMethodAndFieldName(field: FieldData, string1: String, string2: String, publicFieldsToClass: Map<String, ArrayList<String>, currentClass: ClassData): void
    -handlePublicFields(publicFieldsToClass: Map<String, ArrayList<String>, currentClass: ClassData, field: FieldData): void
  }

  class LowCouplingCheck {
    -maxInDegree: int
    -maxOutDegree: int
    -packageName: String
    -checkCycles: boolean
    -ignoreSelf: boolean
    -{static} NAME: String
    -messages: Set<Message>
    -lowestInDegrees: PriorityQueue<IntegerAndDegree>
    +gRun(config: Configuration): Set<Message>
    -checkCycles(): Set<Message>
    -recurseThroughClasses(): void
    -checkGraphDegrees(): void
    -handleExceededMaxOutDegree(i: int): void
    -handleExceededMaxInDegree(i: int): void
    -handleNegativeGraphDegrees(): void
    -parseConfig(config: Configuration): void
    -recursion(it: ClassGraphIterator, messages: Set<Message>, pq: PriorityQueue<IntegerAndDegree>, ignoreSelf: boolean): void
    -recurseThroughEdges(it: ClassGraphIterator, messages: Set<Message>, pq: PriorityQueue<IntegerAndDegree>, ignoreSelf: boolean): void
    -handleCycle(it: ClassGraphIterator, messages: Set<Message>, ignoreSelf: boolean): boolean
    -cyclePrint(classes: List<String>): String
  }

  class IntegerAndDegree <<Comparable>> {
    index: int
    inDegree: int
    compareTo(o: IntegerAndDegree): int
  }

  class MethodLengthCheck {
    -{static} NAME: String
    -{static} MAX_METHOD_LENGTH_KEY: String
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
    -checkClass(classData: ClassData, maxMethodLengthInstrs: int, messages: Set<Messages>): void
  }

  enum NamingConventions {
    lowercase
    UPPERCASE
    UPPER_CASE
    lower_case
    camelCase
    PascalCase
    ANY
    -checker: Function<char[], Boolean>
    +check(chars: char[]): boolean
  }

  class NamingConventionsCheck {
    -{static} NAME: String
    -checkConvention(str: String, convention: NamingConventions): boolean
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
    -runClassChecks(classInfo: ClassData, maxLength: int, messages: Set<Message>, methodNames: NamingConventions, methodParamNames: NamingConventions, localVarNames: NamingConventions): void
    -runMethodChecks(classInfo: ClassData, maxLength: int, messages: Set<Message>, methodNames: NamingConventions, methodParamNames: NamingConventions, localVarNames: NamingConventions, m: MethodData): void
    -runLocalVariableChecks(classInfo: ClassData, maxLength: int, messages: Set<Message>, methodNames: NamingConventions, methodParamNames: NamingConventions, localVarNames: NamingConventions, m: MethodData): void
    -runLocalVariableCheck(classInfo: ClassData, maxLength: int, messages: Set<Message>, methodNames: NamingConventions, methodParamNames: NamingConventions, localVarNames: NamingConventions, m: MethodData, lvar: VariableData): void
    -handleParametersWithLocalVariables(classInfo: ClassData, maxLength: int, messages: Set<Message>, methodNames: NamingConventions, methodParamNames: NamingConventions, localVarNames: NamingConventions, m: MethodData, lvar: VariableData): void
    -runFieldChecks(classInfo: ClassData, maxLength: int, messages: Set<Message>, enumConstantNames: NamingConventions, constantNames: NamingConventions, fieldNames: NamingConventions): void
    -handleNonEnumFields(classInfo: ClassData, maxLength: int, messages: Set<Message>, enumConstantNames: NamingConventions, constantNames: NamingConventions, fieldNames: NamingConventions): void
    -handleEnumFields(classInfo: ClassData, maxLength: int, messages: Set<Message>, enumConstantNames: NamingConventions, constantNames: NamingConventions, fieldNames: NamingConventions): void
    -handleEnumField(classInfo: ClassData, maxLength: int, messages: Set<Message>, enumConstantNames: NamingConventions, constantNames: NamingConventions, fieldNames: NamingConventions, f: FieldData): void
    -staticAndFinalCheck(classInfo: ClassData, maxLength: int, messages: Set<Message>, constantNames: NamingConventions, fieldNames: NamingConventions, f: FieldData): void
    -runPackageChecks(classInfo: ClassData, maxLength: int, messages: Set<Message>, packageNames: NamingConventions, allowEmptyPackage: boolean): void
    -checkPackage(packages: Set<String>, maxLength: int, messages: Set<Message>, packageNames: NamingConventions, allowEmptyPackage: boolean, pckg: String): void
    -handleIncorrectConventionsOrEmptyPackage(messages: Set<Message>, packageNames: NamingConventions, allowEmptyPackage: boolean, pckg: String): void
    -runClassNameChecks(classInfo: ClassData, maxLength: int, messages: Set<Message>, abstractNames: NamingConventions, interfaceNames: NamingConventions, enumNames: NamingConventions, classNames: NamingConventions): void
  }

  class NoGlobalVariablesCheck {
    -{static} NAME: String
    +run(classes: ClassDataCollection, config: Configuration): Set<Message>
  }
}

exception IOException {
}

exception Exception {
}

exception IllegalArgumentException {
}

exception RuntimeException {
}

exception FileNotFoundException {
}

exception IllegalStateException {
}

exception ClassCastException {
}
' cli package
App -> ConfigRW
App -> FilesLoader

' datasource.config package
ConfigSpec +- Section
ConfigSpec ->"*" Section
Section +- Setting
Section ->"*" Setting
Setting +- Type
Setting -> Type
JsonFileConfigSpecLoader .|> ConfigSpecLoader

' datasource package
DirLoader ..|> FilesLoader
FullFilePrinter ..|> DataPrinter
JsonFileConfigRW ..|> ConfigRW
ConfigSpecLoader ..> IOException: <<throws>>
JsonFileConfigSpecLoader ..> IOException: <<throws>>
ConfigRW ..> IOException: <<throws>>
Configuration ..> IllegalArgumentException: <<throws>>
Configuration ..> ClassCastException: <<throws>>
DataPrinter ..> FileNotFoundException: <<throws>>
FilesLoader ..> IOException: <<throws>>
FilesLoader ..> IllegalStateException: <<throws>>

' domain.checks package
AdapterPatternCheck --|> Check
ConstantInterfaceCheck --|> Check
GraphCheck  --|> Check
ImmutableExceptionsCheck --|> Check
InformationHidingCheck --|> Check
LowCouplingCheck ->"*" IntegerAndDegree
IntegerAndDegree +- LowCouplingCheck
MethodLengthCheck --|> Check
NamingConventionsCheck --|> Check
NoGlobalVariablesCheck --|> Check

' exceptions
FileNotFoundException --|> IOException
IOException --|> Exception
ClassCastException --|> RuntimeException
IllegalStateException --|> RuntimeException
IllegalArgumentException --|> RuntimeException
RuntimeException --|> Exception
@enduml